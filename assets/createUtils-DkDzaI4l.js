import{as as U,aZ as Q,nb as V,kW as Y,kl as J,kp as K,kV as X,o6 as ee,cx as te,a1 as se,n as v,p as S,c8 as M,u as ae,o7 as H,o8 as re,o9 as ne,cq as d,dS as O,ch as oe,hl as ie,gE as le,h1 as ce,h0 as he,oa as ue,ob as pe,jH as A,cT as z,oc as fe,eY as de,jf as E,dD as me,c$ as ye,k_ as xe,od as q,b2 as ge,c7 as Re,oe as Me}from"./index-Dg_V7Ho7.js";import{j as we}from"./geodesicUtils-BySj0T3d.js";import{c as Te}from"./distanceOperator-DZoq-uFB.js";import{c as be,u as ve}from"./simplifyOperator-DIZlQeMz.js";var L;let R=L=class extends U{constructor(a){super(a),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const a=this.center,e=this.numberOfPoints;if(this.hasZ=a?.hasZ??!1,this.rings.length!==0||!a)return;const t=Q(this.radius,this.radiusUnit,"meters"),r=a.spatialReference;let o,s="geographic";if(r.isWebMercator?s="webMercator":((r.wkid&&V[r.wkid])!=null||(r.wkt2||r.wkt)&&Y(r.wkt2||r.wkt))&&(s="projected"),this.geodesic){let n;switch(s){case"webMercator":n=J(a);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":n=a}o=this._createGeodesicCircle(n,t,e),s==="webMercator"&&(o=K(o))}else{let n;s==="webMercator"||s==="projected"?n=t/X(a.spatialReference):s==="geographic"&&(n=ee(t,"meters",te(a.spatialReference).radius)),o=this._createPlanarCircle(a,n,e)}this.spatialReference=o.spatialReference,this.addRing(o.rings[0])}clone(){const{center:a,numberOfPoints:e,radius:t,radiusUnit:r,geodesic:o}=this;return new L({center:a?.clone(),numberOfPoints:e,radius:t,radiusUnit:r,geodesic:o})}_createGeodesicCircle(a,e,t){const r=[],o=[a.x,a.y];for(let s=0;s<360;s+=360/t){const n=this.hasZ?[0,0,a.z??0]:[0,0];we(n,o,s,e,se.WGS84),r.push(n)}return r.push(r[0]),new U({rings:[r]})}_createPlanarCircle(a,e,t){const r=[],o=2*Math.PI/t;for(let s=0;s<t;++s){const n=o*s,c=[a.x+Math.cos(-n)*e,a.y+Math.sin(-n)*e];this.hasZ&&c.push(a.z??0),r.push(c)}return r.push(r[0]),new U({spatialReference:a.spatialReference,rings:[r]})}};v([S({type:M})],R.prototype,"center",void 0),v([S()],R.prototype,"geodesic",void 0),v([S()],R.prototype,"numberOfPoints",void 0),v([S()],R.prototype,"radius",void 0),v([S()],R.prototype,"radiusUnit",void 0),R=L=v([ae("esri.geometry.Circle")],R);const We=R;function k(a,e,t=null){return t!=null?[a,e,t]:[a,e]}function i(a,e,t=null){return t!=null?{x:a,y:e,z:t}:{x:a,y:e}}class B{constructor(e){this.spatialReference=e}mapToLocalMultiple(e){return e.map(t=>this.mapToLocal(t)).filter(z)}get doUnnormalization(){return!1}}let $e=class extends B{constructor(e,t,r=null){super(t),this._defaultZ=r,this.transform=H(),this.transformInv=H(),this.transform=re(e),ne(this.transformInv,this.transform)}makeMapPoint(e,t){return k(e,t,this._defaultZ)}mapToLocal(e){return i(this.transform[0]*e[0]+this.transform[2]*e[1]+this.transform[4],this.transform[1]*e[0]+this.transform[3]*e[1]+this.transform[5])}localToMap(e){return k(this.transformInv[0]*e.x+this.transformInv[2]*e.y+this.transformInv[4],this.transformInv[1]*e.x+this.transformInv[3]*e.y+this.transformInv[5],this._defaultZ)}},Se=class extends B{constructor(e,t){super(e.spatialReference),this.view=e,this.defaultZ=null,this.pWS=d(),this.tangentFrameUpWS=d(),this.tangentFrameRightWS=d(),this.tangentFrameForwardWS=d(),this.localFrameRightWS=d(),this.localFrameUpWS=d(),this.worldToLocalTransform=O(),this.localToWorldTransform=O(),this.scale=1,this.scale=e.resolution,this.referenceMapPoint=t,this.defaultZ=t.hasZ?t.z:null;const r=e.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const o=d();oe(o,this.tangentFrameForwardWS,ie(r,this.tangentFrameForwardWS)),le(this.localFrameRightWS,r,o),ce(this.localFrameRightWS,this.localFrameRightWS),he(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),ue(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),pe(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(e,t){return k(e,t,this.defaultZ)}mapToLocal(e){const t=d();this.view.renderCoordsHelper.toRenderCoords(new M({x:e[0],y:e[1],spatialReference:this.spatialReference}),t),A(t,t,this.worldToLocalTransform);const r=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return r!=null?i(r.x/this.scale,r.y/this.scale):null}localToMap(e){const t=d();this.view.renderCoordsHelper.toRenderCoords(new M({x:e.x*this.scale,y:e.y*this.scale,spatialReference:this.spatialReference}),t),A(t,t,this.localToWorldTransform);const r=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return r!=null?k(r.x,r.y,this.defaultZ):null}};function Ie(a,e){if(a.type==="2d")return new $e(a.state.transform,a.spatialReference,e.length>2?e[2]:null);if(a.type==="3d"){const t=e.length>2?new M({x:e[0],y:e[1],z:e[2],spatialReference:a.spatialReference}):new M({x:e[0],y:e[1],spatialReference:a.spatialReference});return new Se(a,t)}return null}function w(a,e){const t=new M({x:a[0],y:a[1],spatialReference:e});return a.length>2&&(t.z=a[2]),t}function Le(a,e){return new Re({points:a,spatialReference:e})}function Ze(a,e,t){const r=new ge({paths:a,spatialReference:e});return t&&q(r),r}function I(a,e,t,r=!0){const o=me(a);o.forEach(n=>{const c=n[0],l=n[n.length-1];ye(c,l)&&n.length!==1||n.push(n[0])});let s=new U({rings:o,spatialReference:e});return s.rings.forEach(n=>{xe(n)||n.reverse()}),t&&q(s),r&&!be(s)&&E(e)&&(s=ve(s)||s),s}function _e(a,e,t){const r=e.mapToLocalMultiple(a),o=[],s={x:r[0].x,y:r[0].y},n={x:r[1].x,y:r[1].y},c=Math.round(n.x-s.x),l=Math.round(n.y-s.y),p=Math.max(Math.abs(c),Math.abs(l));if(t){const h={x:s.x+p,y:s.y+p},m={x:s.x-p,y:s.y-p};o.push(i(h.x,m.y),i(m.x,m.y),i(m.x,h.y),i(h.x,h.y))}else{const h={x:c>0?s.x+p:s.x-p,y:l>0?s.y+p:s.y-p};o.push(i(s.x,s.y),i(h.x,s.y),i(h.x,h.y),i(s.x,h.y))}return G(I([o.map(h=>e.localToMap(h)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function je(a,e,t){let r=e.mapToLocalMultiple(a);if(r.length===1){const l=r[0];r=[i(l.x-48,l.y+48),i(l.x+48,l.y-48),i(l.x+48,l.y-48),i(l.x-48,l.y+48)]}const o=[],s={x:r[0].x,y:r[0].y},n={x:r[1].x,y:r[1].y};if(t){const c=Math.round(n.x-s.x),l=Math.round(n.y-s.y);o.push(i(s.x-c,s.y-l),i(n.x,s.y-l),i(n.x,n.y),i(s.x-c,n.y))}else o.push(i(s.x,s.y),i(n.x,s.y),i(n.x,n.y),i(s.x,n.y));return G(I([o.map(c=>e.localToMap(c)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function G(a,e,t){const r=P(e[3],e[2],t),o=P(e[1],e[2],t),s=P(e[0],e[1],t),n=P(e[0],e[3],t);return{geometry:a,midpoints:r!=null&&o!=null&&s!=null&&n!=null?{top:r,right:o,bottom:s,left:n}:null}}function P(a,e,t){W[0]=a.x,W[1]=a.y,W[2]=0,$[0]=e.x,$[1]=e.y,$[2]=0,Me(W,W,$,.5),C.x=W[0],C.y=$[1],C.z=$[2];const r=t.localToMap(C);return r!=null?w(r,t.spatialReference):null}const C=i(0,0,0),W=d(),$=d();function He(a,e,t,r){const o=e.mapToLocalMultiple(a);let s=null,n=null;if(t)s=o[0],n=o[1];else{const u=o[0],f=o[1],T=Math.round(f.x-u.x),b=Math.round(f.y-u.y),y=Math.max(Math.abs(T),Math.abs(b));s=i(T>0?u.x+y/2:u.x-y/2,b>0?u.y+y/2:u.y-y/2),n=i(Math.abs(T)>Math.abs(b)?s.x-y/2:s.x,Math.abs(T)>Math.abs(b)?s.y:s.y-y/2)}const c=e.localToMap(s),l=e.localToMap(n);if(c==null||l==null)return null;e.doUnnormalization&&fe([[c,l]],e.spatialReference);const p=w(c,e.spatialReference),h=w(l,e.spatialReference),m=de(e.spatialReference);let x=0;if(E(e.spatialReference))x=m*Te(p,h);else{const u=s.x-n.x,f=s.y-n.y;x=m*Math.sqrt(u*u+f*f)*1}const F=new We({center:p,radius:x,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:I(F.rings,F.spatialReference,!1),center:p,edge:h}}function Oe(a,e,t){const r=e.mapToLocalMultiple(a),o=r[0],s=r[1],n=Math.round(s.x-o.x),c=Math.round(s.y-o.y),l=i(t?o.x:o.x+n/2,t?o.y:o.y+c/2),p=t?n:n/2,h=t?c:c/2,m=60,x=[],F=2*Math.PI/m;function u(g){const N=Math.cos(g),D=Math.sin(g);return i(p*N+l.x,h*D+l.y)}for(let g=0;g<m;g++)x.push(u(g*F));x.push(x[0]);const{spatialReference:f,doUnnormalization:T}=e,b=I([x.map(g=>e.localToMap(g)).filter(z)],f,T,!1),y=e.localToMap(u(Math.PI/2)),Z=e.localToMap(u(0)),_=e.localToMap(u(-Math.PI/2)),j=e.localToMap(u(Math.PI));return{geometry:b,midpoints:y!=null&&Z!=null&&_!=null&&j!=null?{top:w(y,f),right:w(Z,f),bottom:w(_,f),left:w(j,f)}:null}}export{Le as R,I as T,je as U,Ie as W,_e as b,Ze as j,He as k,Oe as v};
